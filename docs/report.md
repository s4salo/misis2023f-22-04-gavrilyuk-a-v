# Вопрос: СУБД - табличные/реляционные (SQL)
# Подготовил: Гаврилюк А.В. БПМ-22-4

## Реляционная модель
Реляционная модель - это интуитивно понятный, наглядный табличный способ представления данных. Каждая строка, содержащаяся в таблице такой базы данных, представляет собой запись с уникальным идентификатором, который называют ключом. Столбцы таблицы являются атрибутами, а каждая запись содержит значение для каждого атрибута. Это дает возможность устанавливать взаимосвязь между элементами данных.

## Реляционная база данных
Реляционная база данных — это составленная по реляционной модели база данных, в которой данные, занесенные в таблицы, имеют изначально заданные отношения. Сами таблицы в такой базе данных также соотносятся друг с другом строго определенным образом с помощью первичных и внешних ключей.[Relational Databases]

## SQL
Для взаимодействия с любой реляционной базой данных используется SQL — язык структурированных запросов. Это основа интерфейса систем управления базами данных.[Relational Databases] Он включает в себя такие операции, как создание таблиц (CREATE TABLE), вставка данных (INSERT), обновление данных (UPDATE), удаление данных (DELETE) и получение данных (SELECT).

Фильтрация и сортировка данных реализуются с помощью соответствующих ключевых слов - WHERE и ORDER BY. Агрегатные функции такие как COUNT(), SUM(), AVG() и др. служат для суммирования и статистической обработки данных, используются в связке с GROUP BY. 

## Использование реляционной базы данных при написании C++ приложений
Существуют несколько C++ библиотек для работы с реляционными базами данных. Рассмотрим пример работы с базами данных на C++ с помощью библиотеки MySQL Connector/C++. Она предоставляет набор классов и функций, которые позволяют взаимодействовать с MySQL сервером.
### Установка соединения с базой данных
```c++
sql::mysql::MySQL_Driver *driver;
sql::Connection *con;
driver = sql::mysql::get_mysql_driver_instance();
con = driver->connect("tcp://127.0.0.1:3306", "username", "password");
delete con;
```
_пример взят из [MySQL Connector/C++]_

Здесь мы объявляем указатели на объекты MySQL_Driver и Connection.<br/>
Далее получаем экземпляр драйвера MySQL.<br/>
Затем создаем соединение с базой данных, указывая адрес сервера MySQL, порт, имя пользователя и пароль.<br/>
### Создание таблицы
```c++
sql::Statement *stmt;
stmt = con->createStatement();
stmt->execute("CREATE DATABASE IF NOT EXISTS mydatabase");
con->setSchema("mydatabase");
stmt->execute("CREATE TABLE IF NOT EXISTS students (id INT, name VARCHAR(50), age INT)");
delete stmt;
```
_пример взят из [MySQL Connector/C++]_<br/><br/>
Метод execute() в MySQL Connector/C++ используется для выполнения простого SQL-запроса, который ничего не возвращает.
В этом примере мы создаем объект Statement с помощью которого будем выполнять SQL-запросы.
Далее с помощью метода execute() мы создаем базу данных с именем "mydatabase", если такой еще не существует, и указываем, что собираемся использовать именно эту базу данных с помощью метода setSchema().
Затем также с помощью execute() мы создаем нужную нам таблицу.
#### Динамическое создание таблиц
```c++
sql::TableDefinition table("students");
table.addColumnDefinition("id INT");
table.addColumnDefinition("name VARCHAR(50)");
table.addColumnDefinition("age INT");
stmt->execute(table.toString());
```
Можно использовать sql::TableDefinition и addColumnDefinition() для создания таблицы вместо написания SQL-запроса в качестве аргумента метода execute().
### Выборка результатов
Метод executeQuery() позволяет выполнить SQL-запрос, возвращающий данные, и получить доступ к ним в виде объекта sql::ResultSet.
```c++
sql::Statement *stmt;
stmt = con->createStatement();

sql::ResultSet *res;
res = stmt->executeQuery("SELECT id, name, age FROM students");

while (res->next()) {
  int id = res->getInt("id");
  std::string name = res->getString("name");
  std::cout << "ID: " << id << ", Name: " << name << std::endl;
}
delete res;
delete stmt;
```
Для перебора всех строк выборки можно использовать метод next(), который перемещает указатель на следующую строку выборки и проверяет, есть ли следующая строка. С помощью методов getInt(), getString() и других можно получить значения соответствующих столбцов для каждой строки.

### Prepared Statements
std::PreparedStatement в MySQL Connector/C++ представляет подготовленное SQL-выражение, которое может содержать параметры.
```c++
sql::PreparedStatement *prepStmt;
prepStmt = con->prepareStatement("INSERT INTO mytable (name, age) VALUES (?, ?)");

prepStmt->setString(1, "John");
prepStmt->setInt(2, 25);
prepStmt->execute()

delete prepStmt;
```
_пример взят из [MySQL Connector/C++]_<br/>
С помошью std::PreparedStatement мы можем использовать хранимые процедуры и получать результат их работы с помощью этого кода:
```c++
sql::ResultSet *result = prepStmt->getResultSet();
```

## Заключение
Реляционная модель является одной из самых распространенных и популярных моделей хранения и обработки данных. Она отличается простотой, наглядностью представления информации и возможностью устанавливать отношения между объектами.
Сейчас существует множество удобных инструментов, предназначенных для работы с реляционными базами данных, которые позволяют упростить работу с ними. Эти инструменты предоставляют более высокий уровень абстракции.

## Источники
[Relational Databases] https://cloud.yandex.ru/ru/docs/glossary/relational-databases<br/>
[MySQL Connector/C++] https://dev.mysql.com/doc/connector-cpp/1.1/en/


