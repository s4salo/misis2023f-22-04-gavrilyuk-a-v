# Вопрос: СУБД - табличные/реляционные (SQL)
# Подготовил: Гаврилюк А.В. БПМ-22-4

## Реляционная модель
Реляционная модель - это табличный способ представления данных. Каждая строка, содержащаяся в таблице такой базы данных, представляет собой запись с уникальным идентификатором, который называют ключом. Столбцы таблицы являются атрибутами, а каждая запись содержит значение для каждого атрибута. [1]

## Преимущества и недостатки реляционной модели
Преимущества:
- РБД поддерживают транзакции, благодаря которым можно добиться атомарности операций, согласованности данных, а также защищенности от аппаратных сбоев.
- Безопасность. РБД предоставляют механизмы для аутентификации и авторизации пользователей, а также контроля доступа к данным.
- Стандартизация. Повсеместное использование SQL означает, что с навыками работы с одной РБД можно быстро адаптироваться к другим.<br/>

Недостатки:
- При создании РБД необходимо заранее определять структуру таблиц и типы данных. Изменение структуры на ходу может оказаться непростой задачей.
- Трудность понимания структуры данных из-за большого количества таблиц.
- Не всегда предметную область легко представить в виде таблиц, например временные ряды.
## SQL
Для взаимодействия с реляционными базами данных используется SQL — язык структурированных запросов. Это основа интерфейса систем управления базами данных. Он включает в себя такие операции, как создание таблиц (CREATE TABLE), вставка данных (INSERT), обновление данных (UPDATE), удаление данных (DELETE) и получение данных (SELECT)[3].

Фильтрация и сортировка данных реализуются с помощью соответствующих ключевых слов - WHERE и ORDER BY. Агрегатные функции такие как COUNT(), SUM(), AVG() служат для суммирования и статистической обработки данных, используются в связке с GROUP BY. 

## Использование реляционной базы данных при написании C++ приложений
Существуют несколько C++ библиотек для работы с реляционными базами данных. Рассмотрим пример работы с базами данных на C++ с помощью библиотеки MySQL Connector/C++. Она предоставляет набор классов и функций, которые позволяют взаимодействовать с MySQL сервером.
### Установка соединения с базой данных
```c++
sql::mysql::MySQL_Driver *driver;
sql::Connection *con;
driver = sql::mysql::get_mysql_driver_instance();
con = driver->connect("tcp://127.0.0.1:3306", "username", "password");
delete con;
```
_пример взят из [2]_

Здесь мы объявляем указатели на объекты MySQL_Driver и Connection.<br/>
Далее получаем экземпляр драйвера MySQL.<br/>
Затем создаем соединение с базой данных, указывая адрес сервера MySQL, порт, имя пользователя и пароль.<br/>
### Создание таблицы
```c++
sql::Statement *stmt;
stmt = con->createStatement();
stmt->execute("CREATE DATABASE IF NOT EXISTS mydatabase");
con->setSchema("mydatabase");
stmt->execute("CREATE TABLE IF NOT EXISTS students (id INT, name VARCHAR(50), age INT)");
delete stmt;
```
_пример взят из [2]_<br/><br/>
Метод execute() в MySQL Connector/C++ используется для выполнения простого SQL-запроса, который ничего не возвращает.
В этом примере мы создаем объект Statement с помощью которого будем выполнять SQL-запросы.
Далее с помощью метода execute() мы создаем базу данных с именем "mydatabase", если такой еще не существует, и указываем, что собираемся использовать именно эту базу данных с помощью метода setSchema().
Затем также с помощью execute() мы создаем нужную нам таблицу.
#### Динамическое создание таблиц
```c++
sql::TableDefinition table("students");
table.addColumnDefinition("id INT");
table.addColumnDefinition("name VARCHAR(50)");
table.addColumnDefinition("age INT");
stmt->execute(table.toString());
```
Можно использовать sql::TableDefinition и addColumnDefinition() для создания таблицы вместо написания SQL-запроса в качестве аргумента метода execute().
### Выборка результатов
Метод executeQuery() позволяет выполнить SQL-запрос, возвращающий данные, и получить доступ к ним в виде объекта sql::ResultSet.
```c++
sql::Statement *stmt;
stmt = con->createStatement();

sql::ResultSet *res;
res = stmt->executeQuery("SELECT id, name, age FROM students");

while (res->next()) {
  int id = res->getInt("id");
  std::string name = res->getString("name");
  std::cout << "ID: " << id << ", Name: " << name << std::endl;
}
delete res;
delete stmt;
```
Для перебора всех строк выборки можно использовать метод next(), который перемещает указатель на следующую строку выборки и проверяет, есть ли следующая строка. С помощью методов getInt(), getString() и других можно получить значения соответствующих столбцов для каждой строки.

### Prepared Statements
std::PreparedStatement в MySQL Connector/C++ представляет подготовленное SQL-выражение, которое может содержать параметры.
```c++
sql::PreparedStatement *prepStmt;
prepStmt = con->prepareStatement("INSERT INTO mytable (name, age) VALUES (?, ?)");

prepStmt->setString(1, "John");
prepStmt->setInt(2, 25);
prepStmt->execute()

delete prepStmt;
```
_пример взят из [2]_<br/>
С помошью std::PreparedStatement мы можем использовать хранимые процедуры и получать результат их работы с помощью этого кода:
```c++
sql::ResultSet *result = prepStmt->getResultSet();
```

## Заключение
Реляционная база данных - это удобный способ хранения данных. Она позволяет структурировать и организовать информацию в виде таблиц с реляционными связями между ними. Это полезно при работе с данными, где необходимо обеспечить целостность, согласованность и эффективность операций доступа к данным.

## Источники
[1] https://cloud.yandex.ru/ru/docs/glossary/relational-databases<br/>
[2] https://dev.mysql.com/doc/connector-cpp/1.1/en/
[3] https://ru.wikipedia.org/wiki/SQL#Элементы


